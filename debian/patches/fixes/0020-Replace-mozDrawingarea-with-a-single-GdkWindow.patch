From f95cd860456ef90c86d703e5c00689042073f7ae Mon Sep 17 00:00:00 2001
From: Mike Hommey <mh@glandium.org>
Date: Thu, 25 Feb 2010 10:55:26 +0100
Subject: [PATCH 20/30] Replace mozDrawingarea with a single GdkWindow

https://bugzilla.mozilla.org/show_bug.cgi?id=506433
---
 widget/src/gtk2/Makefile.in      |    2 -
 widget/src/gtk2/mozdrawingarea.c |  241 --------------------------
 widget/src/gtk2/mozdrawingarea.h |  101 -----------
 widget/src/gtk2/nsWindow.cpp     |  349 ++++++++++++++++++--------------------
 widget/src/gtk2/nsWindow.h       |    3 +-
 5 files changed, 167 insertions(+), 529 deletions(-)
 delete mode 100644 widget/src/gtk2/mozdrawingarea.c
 delete mode 100644 widget/src/gtk2/mozdrawingarea.h

diff --git a/widget/src/gtk2/Makefile.in b/widget/src/gtk2/Makefile.in
index 0df722e..39654b1 100644
--- a/widget/src/gtk2/Makefile.in
+++ b/widget/src/gtk2/Makefile.in
@@ -78,7 +78,6 @@ endif
 
 CSRCS		= \
 		mozcontainer.c \
-		mozdrawingarea.c \
 		keysym2ucs.c \
 		nsPrintdGTK.c \
 		$(NULL)
@@ -152,7 +151,6 @@ endif
 EXPORTS		= \
                 nsGTKToolkit.h \
 		nsIImageToPixbuf.h \
-		mozdrawingarea.h \
 		mozcontainer.h \
 		$(NULL)
 
diff --git a/widget/src/gtk2/mozdrawingarea.c b/widget/src/gtk2/mozdrawingarea.c
deleted file mode 100644
index 5b7cf99..0000000
--- a/widget/src/gtk2/mozdrawingarea.c
+++ /dev/null
@@ -1,241 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
-/* vim:expandtab:shiftwidth=4:tabstop=4:
- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is Christopher Blizzard
- * <blizzard@mozilla.org>.  Portions created by the Initial Developer
- * are Copyright (C) 2001 the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#include "mozdrawingarea.h"
-
-/* init methods */
-static void moz_drawingarea_class_init          (MozDrawingareaClass *klass);
-static void moz_drawingarea_init                (MozDrawingarea *drawingarea);
-
-/* static methods */
-static void moz_drawingarea_create_windows      (MozDrawingarea *drawingarea,
-                                                 GdkWindow *parent,
-                                                 GtkWidget *widget,
-                                                 GdkVisual *visual);
-
-static void moz_drawingarea_finalize            (GObject *object);
-
-static GObjectClass *parent_class = NULL;
-
-GtkType
-moz_drawingarea_get_type(void)
-{
-    static GtkType moz_drawingarea_type = 0;
-
-   if (!moz_drawingarea_type) {
-       static GTypeInfo moz_drawingarea_info = {
-           sizeof(MozDrawingareaClass), /* class size */
-           NULL, /* base_init */
-           NULL, /* base_finalize */
-           (GClassInitFunc) moz_drawingarea_class_init, /* class_init */
-           NULL, /* class_destroy */
-           NULL, /* class_data */
-           sizeof(MozDrawingarea), /* instance_size */
-           0, /* n_preallocs */
-           (GInstanceInitFunc) moz_drawingarea_init, /* instance_init */
-           NULL, /* value_table */
-       };
-       moz_drawingarea_type =
-           g_type_register_static (G_TYPE_OBJECT,
-                                   "MozDrawingarea",
-                                   &moz_drawingarea_info, 0);
-   }
-
-   return moz_drawingarea_type;
-}
-
-MozDrawingarea *
-moz_drawingarea_new (MozDrawingarea *parent, MozContainer *widget_parent,
-                     GdkVisual *visual)
-{
-    MozDrawingarea *drawingarea;
-
-    drawingarea = g_object_new(MOZ_DRAWINGAREA_TYPE, NULL);
-
-    if (!parent)
-        moz_drawingarea_create_windows(drawingarea,
-                                       GTK_WIDGET(widget_parent)->window,
-                                       GTK_WIDGET(widget_parent),
-                                       visual);
-    else
-        moz_drawingarea_create_windows(drawingarea,
-                                       parent->inner_window, 
-                                       GTK_WIDGET(widget_parent),
-                                       visual);
-
-    return drawingarea;
-}
-
-void
-moz_drawingarea_class_init (MozDrawingareaClass *klass)
-{
-    GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
-    object_class->finalize = moz_drawingarea_finalize;
-
-    parent_class = g_type_class_peek_parent(klass);
-}
-
-void
-moz_drawingarea_init (MozDrawingarea *drawingarea)
-{
-
-}
-
-void
-moz_drawingarea_reparent (MozDrawingarea *drawingarea, GdkWindow *aNewParent)
-{
-    gdk_window_reparent(drawingarea->clip_window,
-                        aNewParent, 0, 0);
-}
-
-void
-moz_drawingarea_create_windows (MozDrawingarea *drawingarea, GdkWindow *parent,
-                                GtkWidget *widget, GdkVisual *visual)
-{
-    GdkWindowAttr attributes;
-    gint          attributes_mask = 0;
-
-    /* create the clipping window */
-    attributes.event_mask = 0;
-    attributes.x = 0;
-    attributes.y = 0;
-    attributes.width = 1;
-    attributes.height = 1;
-    attributes.wclass = GDK_INPUT_OUTPUT;
-    attributes.window_type = GDK_WINDOW_CHILD;
-    if (!visual) {
-        attributes.visual = gtk_widget_get_visual (widget);
-        attributes.colormap = gtk_widget_get_colormap (widget);
-    } else {
-        attributes.visual = visual;
-        attributes.colormap = gdk_colormap_new(visual, 0);
-    }
-
-    attributes_mask |= GDK_WA_VISUAL | GDK_WA_COLORMAP |
-        GDK_WA_X | GDK_WA_Y;
-
-    drawingarea->clip_window = gdk_window_new (parent, &attributes,
-                                               attributes_mask);
-    gdk_window_set_user_data(drawingarea->clip_window, widget);
-
-    /* set the default pixmap to None so that you don't end up with the
-       gtk default which is BlackPixel. */
-    gdk_window_set_back_pixmap(drawingarea->clip_window, NULL, FALSE);
-
-    attributes.event_mask = (GDK_EXPOSURE_MASK | GDK_STRUCTURE_MASK |
-                             GDK_VISIBILITY_NOTIFY_MASK |
-                             GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK |
-                             GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
-#ifdef HAVE_GTK_MOTION_HINTS
-                             GDK_POINTER_MOTION_HINT_MASK |
-#endif
-                             GDK_POINTER_MOTION_MASK);
-    /* create the inner window */
-    drawingarea->inner_window = gdk_window_new (drawingarea->clip_window,
-                                                &attributes, attributes_mask);
-    gdk_window_set_user_data(drawingarea->inner_window, widget);
-
-    /* set the default pixmap to None so that you don't end up with the
-       gtk default which is BlackPixel. */
-    gdk_window_set_back_pixmap(drawingarea->inner_window, NULL, FALSE);
-
-    if (visual) {
-        g_object_unref(attributes.colormap);
-    }
-}
-
-void
-moz_drawingarea_finalize (GObject *object)
-{
-    MozDrawingarea *drawingarea;
-    gpointer user_data;
-
-    g_return_if_fail(IS_MOZ_DRAWINGAREA(object));
-
-    drawingarea = MOZ_DRAWINGAREA(object);
-
-    gdk_window_destroy(drawingarea->inner_window);
-    gdk_window_destroy(drawingarea->clip_window);
-
-    (* parent_class->finalize) (object);
-}
-
-void
-moz_drawingarea_move (MozDrawingarea *drawingarea,
-                      gint x, gint y)
-{
-    gdk_window_move(drawingarea->clip_window, x, y);
-}
-
-void
-moz_drawingarea_resize (MozDrawingarea *drawingarea,
-                        gint width, gint height)
-{
-    gdk_window_resize(drawingarea->clip_window, width, height);
-    gdk_window_resize(drawingarea->inner_window, width, height);
-}
-
-void
-moz_drawingarea_move_resize (MozDrawingarea *drawingarea,
-                             gint x, gint y, gint width, gint height)
-{
-    gdk_window_resize(drawingarea->inner_window, width, height);
-    gdk_window_move_resize(drawingarea->clip_window, x, y, width, height);
-}
-
-void
-moz_drawingarea_set_visibility (MozDrawingarea *drawingarea,
-                                gboolean visibility)
-{
-    if (visibility) {
-        gdk_window_show_unraised(drawingarea->inner_window);
-        gdk_window_show_unraised(drawingarea->clip_window);
-    }
-    else    {
-        gdk_window_hide(drawingarea->clip_window);
-        gdk_window_hide(drawingarea->inner_window);
-    }
-}
-
-void
-moz_drawingarea_scroll (MozDrawingarea *drawingarea,
-                        gint x, gint y)
-{
-    gdk_window_scroll(drawingarea->inner_window, x, y);
-}
diff --git a/widget/src/gtk2/mozdrawingarea.h b/widget/src/gtk2/mozdrawingarea.h
deleted file mode 100644
index bdcc6d3..0000000
--- a/widget/src/gtk2/mozdrawingarea.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
-/* vim:expandtab:shiftwidth=4:tabstop=4:
- */
-/* ***** BEGIN LICENSE BLOCK *****
- * Version: MPL 1.1/GPL 2.0/LGPL 2.1
- *
- * The contents of this file are subject to the Mozilla Public License Version
- * 1.1 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * http://www.mozilla.org/MPL/
- *
- * Software distributed under the License is distributed on an "AS IS" basis,
- * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
- * for the specific language governing rights and limitations under the
- * License.
- *
- * The Original Code is mozilla.org code.
- *
- * The Initial Developer of the Original Code is Christopher Blizzard
- * <blizzard@mozilla.org>.  Portions created by the Initial Developer
- * are Copyright (C) 2001 the Initial Developer. All Rights Reserved.
- *
- * Contributor(s):
- *
- * Alternatively, the contents of this file may be used under the terms of
- * either the GNU General Public License Version 2 or later (the "GPL"), or
- * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
- * in which case the provisions of the GPL or the LGPL are applicable instead
- * of those above. If you wish to allow use of your version of this file only
- * under the terms of either the GPL or the LGPL, and not to allow others to
- * use your version of this file under the terms of the MPL, indicate your
- * decision by deleting the provisions above and replace them with the notice
- * and other provisions required by the GPL or the LGPL. If you do not delete
- * the provisions above, a recipient may use your version of this file under
- * the terms of any one of the MPL, the GPL or the LGPL.
- *
- * ***** END LICENSE BLOCK ***** */
-
-#ifndef __MOZ_DRAWINGAREA_H__
-#define __MOZ_DRAWINGAREA_H__
-
-#include <gdk/gdkwindow.h>
-#include <gtk/gtkversion.h>
-#include "mozcontainer.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-#define MOZ_DRAWINGAREA_TYPE            (moz_drawingarea_get_type())
-#define MOZ_DRAWINGAREA(obj)            (GTK_CHECK_CAST((obj), MOZ_DRAWINGAREA_TYPE, MozDrawingarea))
-#define MOZ_DRAWINGAREA_CLASS(klass)    (GTK_CHECK_CLASS_CAST((klass), MOZ_DRAWINGAREA_TYPE, MozDrawingareaClass))
-#define IS_MOZ_DRAWINGAREA(obj)         (GTK_CHECK_TYPE((obj), MOZ_DRAWINGAREA_TYPE))
-#define IS_MOZ_DRAWINGAREA_CLASS(klass) (GTK_CHECK_CLASS_TYPE((klass), MOZ_DRAWINGAREA_TYPE))
-#define MOZ_DRAWINGAREA_GET_CLASS(obj)  (GTK_CHECK_GET_CLASS((obj), MOZ_DRAWINGAREA_TYPE, MozDrawingareaClass))
-
-#if (GTK_CHECK_VERSION(2, 12, 0) || \
-    (GTK_CHECK_VERSION(2, 10, 0) && defined(MOZ_PLATFORM_HILDON)))
-#define HAVE_GTK_MOTION_HINTS
-#endif
-
-typedef struct _MozDrawingarea      MozDrawingarea;
-typedef struct _MozDrawingareaClass MozDrawingareaClass;
-
-struct _MozDrawingarea
-{
-    GObject         parent_instance;
-    /* AFAIK this clip_window (and thus this whole class) exists solely to
-     * make gdk_window_scroll() smooth for nsIWidget::Scroll(). */
-    GdkWindow      *clip_window;
-    GdkWindow      *inner_window;
-};
-
-struct _MozDrawingareaClass
-{
-    GObjectClass parent_class;
-};
-
-GtkType         moz_drawingarea_get_type       (void);
-MozDrawingarea *moz_drawingarea_new            (MozDrawingarea *parent,
-                                                MozContainer *widget_parent,
-                                                GdkVisual *visual);
-void            moz_drawingarea_reparent       (MozDrawingarea *drawingarea,
-                                                GdkWindow *aNewParent);
-void            moz_drawingarea_move           (MozDrawingarea *drawingarea,
-                                                gint x, gint y);
-void            moz_drawingarea_resize         (MozDrawingarea *drawingarea,
-                                                gint width, gint height);
-void            moz_drawingarea_move_resize    (MozDrawingarea *drawingarea,
-                                                gint x, gint y,
-                                                gint width, gint height);
-void            moz_drawingarea_set_visibility (MozDrawingarea *drawingarea,
-                                                gboolean visibility);
-void            moz_drawingarea_scroll         (MozDrawingarea *drawingarea,
-                                                gint x, gint y);
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* __MOZ_DRAWINGAREA_H__ */
diff --git a/widget/src/gtk2/nsWindow.cpp b/widget/src/gtk2/nsWindow.cpp
index b9cca02..d769178 100644
--- a/widget/src/gtk2/nsWindow.cpp
+++ b/widget/src/gtk2/nsWindow.cpp
@@ -136,6 +136,11 @@ D_DEBUG_DOMAIN( ns_Window, "nsWindow", "nsWindow" );
 #define D_DEBUG_AT(x,y...)    do {} while (0)
 #endif
 
+#if (GTK_CHECK_VERSION(2, 12, 0) || \
+    (GTK_CHECK_VERSION(2, 10, 0) && defined(MOZ_PLATFORM_HILDON)))
+#define HAVE_GTK_MOTION_HINTS
+#endif
+
 // Don't put more than this many rects in the dirty region, just fluff
 // out to the bounding-box if there are more
 #define MAX_RECTS_IN_REGION 100
@@ -368,7 +373,7 @@ nsWindow::nsWindow()
     mPreferredWidth   = 0;
     mPreferredHeight  = 0;
     mContainer           = nsnull;
-    mDrawingarea         = nsnull;
+    mGdkWindow           = nsnull;
     mShell               = nsnull;
     mWindowGroup         = nsnull;
     mContainerGotFocus   = PR_FALSE;
@@ -806,25 +811,17 @@ nsWindow::Destroy(void)
         // widget while the GdkWindow hierarchy is still available.
         // (OnContainerUnrealize does this when the MozContainer widget is
         // destroyed.)
-        SetWidgetForHierarchy(mDrawingarea->clip_window, owningWidget, NULL);
+        SetWidgetForHierarchy(mGdkWindow, owningWidget, NULL);
     }
 
-    if (mDrawingarea) {
-        g_object_set_data(G_OBJECT(mDrawingarea->clip_window),
-                          "nsWindow", NULL);
-        g_object_set_data(G_OBJECT(mDrawingarea->inner_window),
-                          "nsWindow", NULL);
+    if (mGdkWindow) {
+        g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", NULL);
 
-        g_object_set_data(G_OBJECT(mDrawingarea->clip_window),
-                          "mozdrawingarea", NULL);
-        g_object_set_data(G_OBJECT(mDrawingarea->inner_window),
-                          "mozdrawingarea", NULL);
-
-        NS_ASSERTION(!get_gtk_widget_for_gdk_window(mDrawingarea->inner_window),
+        NS_ASSERTION(!get_gtk_widget_for_gdk_window(mGdkWindow),
                      "widget reference not removed");
 
-        g_object_unref(mDrawingarea);
-        mDrawingarea = nsnull;
+        gdk_window_destroy(mGdkWindow);
+        mGdkWindow = nsnull;
     }
 
     if (gInvisibleContainer && owningWidget == gInvisibleContainer) {
@@ -851,7 +848,7 @@ nsWindow::GetParent(void)
 NS_IMETHODIMP
 nsWindow::SetParent(nsIWidget *aNewParent)
 {
-    if (mContainer || !mDrawingarea || !mParent) {
+    if (mContainer || !mGdkWindow || !mParent) {
         NS_NOTREACHED("nsWindow::SetParent - reparenting a non-child window");
         return NS_ERROR_NOT_IMPLEMENTED;
     }
@@ -866,12 +863,12 @@ nsWindow::SetParent(nsIWidget *aNewParent)
     if (!oldContainer) {
         // The GdkWindows have been destroyed so there is nothing else to
         // reparent.
-        NS_ABORT_IF_FALSE(GDK_WINDOW_OBJECT(mDrawingarea->inner_window)->destroyed,
+        NS_ABORT_IF_FALSE(GDK_WINDOW_OBJECT(mGdkWindow)->destroyed,
                           "live GdkWindow with no widget");
         return NS_OK;
     }
 
-    NS_ABORT_IF_FALSE(!GDK_WINDOW_OBJECT(mDrawingarea->inner_window)->destroyed,
+    NS_ABORT_IF_FALSE(!GDK_WINDOW_OBJECT(mGdkWindow)->destroyed,
                       "destroyed GdkWindow with widget");
 
     GdkWindow* newParentWindow = NULL;
@@ -901,11 +898,10 @@ nsWindow::SetParent(nsIWidget *aNewParent)
         if (newContainer != oldContainer) {
             NS_ABORT_IF_FALSE(!GDK_WINDOW_OBJECT(newParentWindow)->destroyed,
                               "destroyed GdkWindow with widget");
-            SetWidgetForHierarchy(mDrawingarea->clip_window, oldContainer,
-                                  newContainer);
+            SetWidgetForHierarchy(mGdkWindow, oldContainer, newContainer);
         }
 
-        moz_drawingarea_reparent(mDrawingarea, newParentWindow);
+        gdk_window_reparent(mGdkWindow, newParentWindow, 0, 0);
     }
 
     return NS_OK;
@@ -1216,8 +1212,8 @@ nsWindow::Move(PRInt32 aX, PRInt32 aY)
     if (mIsTopLevel) {
         gtk_window_move(GTK_WINDOW(mShell), aX, aY);
     }
-    else if (mDrawingarea) {
-        moz_drawingarea_move(mDrawingarea, aX, aY);
+    else if (mGdkWindow) {
+        gdk_window_move(mGdkWindow, aX, aY);
     }
 
     return NS_OK;
@@ -1244,19 +1240,19 @@ nsWindow::SetZIndex(PRInt32 aZIndex)
 
     NS_ASSERTION(!mContainer, "Expected Mozilla child widget");
 
-    // We skip the nsWindows that don't have mDrawingareas.
+    // We skip the nsWindows that don't have mGdkWindows.
     // These are probably in the process of being destroyed.
 
     if (!GetNextSibling()) {
         // We're to be on top.
-        if (mDrawingarea)
-            gdk_window_raise(mDrawingarea->clip_window);
+        if (mGdkWindow)
+            gdk_window_raise(mGdkWindow);
     } else {
         // All the siblings before us need to be below our widget. 
         for (nsWindow* w = this; w;
              w = static_cast<nsWindow*>(w->GetPrevSibling())) {
-            if (w->mDrawingarea)
-                gdk_window_lower(w->mDrawingarea->clip_window);
+            if (w->mGdkWindow)
+                gdk_window_lower(w->mGdkWindow);
         }
     }
     return NS_OK;
@@ -1500,7 +1496,7 @@ nsWindow::SetCursor(nsCursor aCursor)
 {
     // if we're not the toplevel window pass up the cursor request to
     // the toplevel window to handle it.
-    if (!mContainer && mDrawingarea) {
+    if (!mContainer && mGdkWindow) {
         nsWindow *window = GetContainerWindow();
         if (!window)
             return NS_ERROR_FAILURE;
@@ -1583,7 +1579,7 @@ nsWindow::SetCursor(imgIContainer* aCursor,
 {
     // if we're not the toplevel window pass up the cursor request to
     // the toplevel window to handle it.
-    if (!mContainer && mDrawingarea) {
+    if (!mContainer && mGdkWindow) {
         nsWindow *window = GetContainerWindow();
         if (!window)
             return NS_ERROR_FAILURE;
@@ -1710,10 +1706,10 @@ nsWindow::Validate()
 {
     // Get the update for this window and, well, just drop it on the
     // floor.
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NS_OK;
 
-    GdkRegion *region = gdk_window_get_update_area(mDrawingarea->inner_window);
+    GdkRegion *region = gdk_window_get_update_area(mGdkWindow);
 
     if (region)
         gdk_region_destroy(region);
@@ -1724,6 +1720,9 @@ nsWindow::Validate()
 NS_IMETHODIMP
 nsWindow::Invalidate(PRBool aIsSynchronous)
 {
+    if (!mGdkWindow)
+        return NS_OK;
+
     GdkRectangle rect;
 
     rect.x = mBounds.x;
@@ -1734,13 +1733,9 @@ nsWindow::Invalidate(PRBool aIsSynchronous)
     LOGDRAW(("Invalidate (all) [%p]: %d %d %d %d\n", (void *)this,
              rect.x, rect.y, rect.width, rect.height));
 
-    if (!mDrawingarea)
-        return NS_OK;
-
-    gdk_window_invalidate_rect(mDrawingarea->inner_window,
-                               &rect, FALSE);
+    gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
     if (aIsSynchronous)
-        gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
+        gdk_window_process_updates(mGdkWindow, FALSE);
 
     return NS_OK;
 }
@@ -1749,6 +1744,9 @@ NS_IMETHODIMP
 nsWindow::Invalidate(const nsRect &aRect,
                      PRBool        aIsSynchronous)
 {
+    if (!mGdkWindow)
+        return NS_OK;
+
     GdkRectangle rect;
 
     rect.x = aRect.x;
@@ -1759,13 +1757,9 @@ nsWindow::Invalidate(const nsRect &aRect,
     LOGDRAW(("Invalidate (rect) [%p]: %d %d %d %d (sync: %d)\n", (void *)this,
              rect.x, rect.y, rect.width, rect.height, aIsSynchronous));
 
-    if (!mDrawingarea)
-        return NS_OK;
-
-    gdk_window_invalidate_rect(mDrawingarea->inner_window,
-                               &rect, FALSE);
+    gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
     if (aIsSynchronous)
-        gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
+        gdk_window_process_updates(mGdkWindow, FALSE);
 
     return NS_OK;
 }
@@ -1777,7 +1771,7 @@ nsWindow::InvalidateRegion(const nsIRegion* aRegion,
     GdkRegion *region = nsnull;
     aRegion->GetNativeRegion((void *&)region);
 
-    if (region && mDrawingarea) {
+    if (region && mGdkWindow) {
         GdkRectangle rect;
         gdk_region_get_clipbox(region, &rect);
 
@@ -1785,7 +1779,7 @@ nsWindow::InvalidateRegion(const nsIRegion* aRegion,
                  (void *)this,
                  rect.x, rect.y, rect.width, rect.height, aIsSynchronous));
 
-        gdk_window_invalidate_region(mDrawingarea->inner_window,
+        gdk_window_invalidate_region(mGdkWindow,
                                      region, FALSE);
     }
     else {
@@ -1799,10 +1793,10 @@ nsWindow::InvalidateRegion(const nsIRegion* aRegion,
 NS_IMETHODIMP
 nsWindow::Update()
 {
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NS_OK;
 
-    gdk_window_process_updates(mDrawingarea->inner_window, FALSE);
+    gdk_window_process_updates(mGdkWindow, FALSE);
     return NS_OK;
 }
 
@@ -1817,7 +1811,7 @@ nsWindow::Scroll(PRInt32  aDx,
                  PRInt32  aDy,
                  nsRect  *aClipRect)
 {
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NS_OK;
 
     D_DEBUG_AT( ns_Window, "%s( %4d,%4d )\n", __FUNCTION__, aDx, aDy );
@@ -1827,7 +1821,7 @@ nsWindow::Scroll(PRInt32  aDx,
                      aClipRect->x, aClipRect->y, aClipRect->width, aClipRect->height );
     }
 
-    moz_drawingarea_scroll(mDrawingarea, aDx, aDy);
+    gdk_window_scroll(mGdkWindow, aDx, aDy);
 
     // Update bounds on our child windows
     for (nsIWidget* kid = mFirstChild; kid; kid = kid->GetNextSibling()) {
@@ -1847,10 +1841,10 @@ NS_IMETHODIMP
 nsWindow::ScrollWidgets(PRInt32 aDx,
                         PRInt32 aDy)
 {
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NS_OK;
 
-    moz_drawingarea_scroll(mDrawingarea, aDx, aDy);
+    gdk_window_scroll(mGdkWindow, aDx, aDy);
     return NS_OK;
 }
 
@@ -1868,10 +1862,10 @@ nsWindow::GetNativeData(PRUint32 aDataType)
     switch (aDataType) {
     case NS_NATIVE_WINDOW:
     case NS_NATIVE_WIDGET: {
-        if (!mDrawingarea)
+        if (!mGdkWindow)
             return nsnull;
 
-        return mDrawingarea->inner_window;
+        return mGdkWindow;
         break;
     }
 
@@ -1991,8 +1985,8 @@ nsWindow::WidgetToScreen(const nsRect& aOldRect, nsRect& aNewRect)
                                    &x, &y);
         LOG(("WidgetToScreen (container) %d %d\n", x, y));
     }
-    else if (mDrawingarea) {
-        gdk_window_get_origin(mDrawingarea->inner_window, &x, &y);
+    else if (mGdkWindow) {
+        gdk_window_get_origin(mGdkWindow, &x, &y);
         LOG(("WidgetToScreen (drawing) %d %d\n", x, y));
     }
 
@@ -2013,8 +2007,8 @@ nsWindow::ScreenToWidget(const nsRect& aOldRect, nsRect& aNewRect)
         gdk_window_get_root_origin(GTK_WIDGET(mContainer)->window,
                                    &x, &y);
     }
-    else if (mDrawingarea) {
-        gdk_window_get_origin(mDrawingarea->inner_window, &x, &y);
+    else if (mGdkWindow) {
+        gdk_window_get_origin(mGdkWindow, &x, &y);
     }
 
     aNewRect.x = aOldRect.x - x;
@@ -2065,7 +2059,7 @@ nsWindow::CaptureMouse(PRBool aCapture)
 {
     LOG(("CaptureMouse %p\n", (void *)this));
 
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NS_OK;
 
     GtkWidget *widget = GetMozContainerWidget();
@@ -2089,7 +2083,7 @@ nsWindow::CaptureRollupEvents(nsIRollupListener *aListener,
                               PRBool             aDoCapture,
                               PRBool             aConsumeRollupEvent)
 {
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NS_OK;
 
     GtkWidget *widget = GetMozContainerWidget();
@@ -2271,11 +2265,7 @@ nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
         return FALSE;
     }
 
-    if (!mDrawingarea)
-        return FALSE;
-
-    // handle exposes for the inner window only
-    if (aEvent->window != mDrawingarea->inner_window)
+    if (!mGdkWindow)
         return FALSE;
 
     static NS_DEFINE_CID(kRegionCID, NS_REGION_CID);
@@ -2320,7 +2310,7 @@ nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
     nsRefPtr<gfxContext> ctx = rc->ThebesContext();
 
     gfxPlatformGtk::GetPlatform()->SetGdkDrawable(ctx->OriginalSurface(),
-                                                  GDK_DRAWABLE(mDrawingarea->inner_window));
+                                                  GDK_DRAWABLE(mGdkWindow));
 
     // clip to the update region
     ctx->Save();
@@ -2381,7 +2371,7 @@ nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
         if (gForce24bpp) {
             depth = 24; // 24 always
         } else {
-            depth = gdk_drawable_get_depth(GDK_DRAWABLE(mDrawingarea->inner_window));
+            depth = gdk_drawable_get_depth(GDK_DRAWABLE(mGdkWindow));
         }
 
         if (!gUseBufferPixmap ||
@@ -2390,7 +2380,7 @@ nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
         {
             // create a one-off always if we're not using the global pixmap
             // if gUseBufferPixmap == TRUE, who's redrawing an area bigger than the screen?
-            bufferPixmap = gdk_pixmap_new(GDK_DRAWABLE(mDrawingarea->inner_window),
+            bufferPixmap = gdk_pixmap_new(GDK_DRAWABLE(mGdkWindow),
                                           boundsRect.width, boundsRect.height,
                                           depth);
             bufferPixmapSize.width = boundsRect.width;
@@ -2405,7 +2395,7 @@ nsWindow::OnExposeEvent(GtkWidget *aWidget, GdkEventExpose *aEvent)
             gBufferPixmapSize.width = PR_MAX(gBufferPixmapSize.width, boundsRect.width);
             gBufferPixmapSize.height = PR_MAX(gBufferPixmapSize.height, boundsRect.height);
 
-            gBufferPixmap = gdk_pixmap_new(GDK_DRAWABLE(mDrawingarea->inner_window),
+            gBufferPixmap = gdk_pixmap_new(GDK_DRAWABLE(mGdkWindow),
                                            gBufferPixmapSize.width, gBufferPixmapSize.height,
                                            depth);
 
@@ -2575,8 +2565,8 @@ nsWindow::OnContainerUnrealize(GtkWidget *aWidget)
     NS_ASSERTION(mContainer == MOZ_CONTAINER(aWidget),
                  "unexpected \"unrealize\" signal");
 
-    if (mDrawingarea) {
-        SetWidgetForHierarchy(mDrawingarea->clip_window, aWidget, NULL);
+    if (mGdkWindow) {
+        SetWidgetForHierarchy(mGdkWindow, aWidget, NULL);
     }
 }
 
@@ -2595,10 +2585,10 @@ nsWindow::OnSizeAllocate(GtkWidget *aWidget, GtkAllocation *aAllocation)
     mBounds.width = rect.width;
     mBounds.height = rect.height;
 
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return;
 
-    moz_drawingarea_resize (mDrawingarea, rect.width, rect.height);
+    gdk_window_resize (mGdkWindow, rect.width, rect.height);
 
     if (mTransparencyBitmap) {
       ApplyTransparencyBitmap();
@@ -2668,7 +2658,7 @@ nsWindow::OnLeaveNotifyEvent(GtkWidget *aWidget, GdkEventCrossing *aEvent)
 
     event.time = aEvent->time;
 
-    event.exit = is_top_level_mouse_exit(mDrawingarea->inner_window, aEvent)
+    event.exit = is_top_level_mouse_exit(mGdkWindow, aEvent)
         ? nsMouseEvent::eTopLevel : nsMouseEvent::eChild;
 
     LOG(("OnLeaveNotify: %p\n", (void *)this));
@@ -2797,7 +2787,7 @@ nsWindow::OnMotionNotifyEvent(GtkWidget *aWidget, GdkEventMotion *aEvent)
     }
     else {
         // XXX see OnScrollEvent()
-        if (aEvent->window == mDrawingarea->inner_window) {
+        if (aEvent->window == mGdkWindow) {
             event.refPoint.x = nscoord(aEvent->x);
             event.refPoint.y = nscoord(aEvent->y);
         } else {
@@ -2828,7 +2818,7 @@ nsWindow::InitButtonEvent(nsMouseEvent &aEvent,
                           GdkEventButton *aGdkEvent)
 {
     // XXX see OnScrollEvent()
-    if (aGdkEvent->window == mDrawingarea->inner_window) {
+    if (aGdkEvent->window == mGdkWindow) {
         aEvent.refPoint.x = nscoord(aGdkEvent->x);
         aEvent.refPoint.y = nscoord(aGdkEvent->y);
     } else {
@@ -3373,7 +3363,7 @@ nsWindow::OnScrollEvent(GtkWidget *aWidget, GdkEventScroll *aEvent)
         break;
     }
 
-    if (aEvent->window == mDrawingarea->inner_window) {
+    if (aEvent->window == mGdkWindow) {
         // we are the window that the event happened on so no need for expensive ScreenToWidget
         event.refPoint.x = nscoord(aEvent->x);
         event.refPoint.y = nscoord(aEvent->y);
@@ -3469,12 +3459,12 @@ nsWindow::ThemeChanged()
     nsEventStatus status = nsEventStatus_eIgnore;
     DispatchEvent(&event, status);
 
-    if (!mDrawingarea || NS_UNLIKELY(mIsDestroyed))
+    if (!mGdkWindow || NS_UNLIKELY(mIsDestroyed))
         return;
 
     // Dispatch NS_THEMECHANGED to all child windows
     GList *children =
-        gdk_window_peek_children(mDrawingarea->inner_window);
+        gdk_window_peek_children(mGdkWindow);
     while (children) {
         GdkWindow *gdkWin = GDK_WINDOW(children->data);
 
@@ -3823,6 +3813,38 @@ GetBrandName(nsXPIDLString& brandName)
         brandName.Assign(NS_LITERAL_STRING("Mozilla"));
 }
 
+static GdkWindow *
+CreateGdkWindow(GdkWindow *parent, GtkWidget *widget)
+{
+    GdkWindowAttr attributes;
+    gint          attributes_mask = GDK_WA_VISUAL | GDK_WA_COLORMAP;
+
+    attributes.event_mask = (GDK_EXPOSURE_MASK | GDK_STRUCTURE_MASK |
+                             GDK_VISIBILITY_NOTIFY_MASK |
+                             GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK |
+                             GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+#ifdef HAVE_GTK_MOTION_HINTS
+                             GDK_POINTER_MOTION_HINT_MASK |
+#endif
+                             GDK_POINTER_MOTION_MASK);
+
+    attributes.width = 1;
+    attributes.height = 1;
+    attributes.wclass = GDK_INPUT_OUTPUT;
+    attributes.visual = gtk_widget_get_visual(widget);
+    attributes.colormap = gtk_widget_get_colormap(widget);
+    attributes.window_type = GDK_WINDOW_CHILD;
+
+    GdkWindow *window = gdk_window_new(parent, &attributes, attributes_mask);
+    gdk_window_set_user_data(window, widget);
+
+    /* set the default pixmap to None so that you don't end up with the
+       gtk default which is BlackPixel. */
+    gdk_window_set_back_pixmap(window, NULL, FALSE);
+
+    return window;
+}
+
 nsresult
 nsWindow::NativeCreate(nsIWidget        *aParent,
                        nsNativeWidget    aNativeParent,
@@ -3866,8 +3888,7 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
     }
 
     // figure out our parent window
-    MozDrawingarea *parentArea = nsnull;
-    MozContainer   *parentMozContainer = nsnull;
+    GtkWidget      *parentMozContainer = nsnull;
     GtkContainer   *parentGtkContainer = nsnull;
     GdkWindow      *parentGdkWindow = nsnull;
     GtkWindow      *topLevelParent = nsnull;
@@ -3880,28 +3901,10 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
         parentGtkContainer = GTK_CONTAINER(aNativeParent);
 
     if (parentGdkWindow) {
-        // find the mozarea on that window
-        gpointer user_data = nsnull;
-        user_data = g_object_get_data(G_OBJECT(parentGdkWindow),
-                                      "mozdrawingarea");
-        parentArea = MOZ_DRAWINGAREA(user_data);
-
-        NS_ASSERTION(parentArea, "no drawingarea for parent widget!\n");
-        if (!parentArea)
-            return NS_ERROR_FAILURE;
-
-        // get the user data for the widget - it should be a container
-        user_data = nsnull;
-        gdk_window_get_user_data(parentArea->inner_window, &user_data);
-        NS_ASSERTION(user_data, "no user data for parentArea\n");
-        if (!user_data)
-            return NS_ERROR_FAILURE;
+        // get the widget for the window - it should be a moz container
+        parentMozContainer = get_gtk_widget_for_gdk_window(parentGdkWindow);
 
-        // Get the parent moz container
-        parentMozContainer = MOZ_CONTAINER(user_data);
-        NS_ASSERTION(parentMozContainer,
-                     "owning widget is not a mozcontainer!\n");
-        if (!parentMozContainer)
+        if (!IS_MOZ_CONTAINER(parentMozContainer))
             return NS_ERROR_FAILURE;
 
         // get the toplevel window just in case someone needs to use it
@@ -3910,8 +3913,6 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
             GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(parentMozContainer)));
     }
 
-    GdkVisual* visual = nsnull;
-
     // ok, create our windows
     switch (mWindowType) {
     case eWindowType_dialog:
@@ -3939,11 +3940,11 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
                 GdkWindow* dialoglead = mShell->window;
                 gdk_window_set_group(dialoglead, dialoglead);
             }
-            if (parentArea) {
+            if (parentGdkWindow) {
                 nsWindow *parentnsWindow =
-                    get_window_for_gdk_window(parentArea->inner_window);
+                    get_window_for_gdk_window(parentGdkWindow);
                 NS_ASSERTION(parentnsWindow,
-                             "no nsWindow for parentArea!");
+                             "no nsWindow for parentGdkWindow!");
                 if (parentnsWindow && parentnsWindow->mWindowGroup) {
                     gtk_window_group_add_window(parentnsWindow->mWindowGroup,
                                                 GTK_WINDOW(mShell));
@@ -4009,15 +4010,16 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
         }
 
         // create our container
-        mContainer = MOZ_CONTAINER(moz_container_new());
-        gtk_container_add(GTK_CONTAINER(mShell), GTK_WIDGET(mContainer));
-        gtk_widget_realize(GTK_WIDGET(mContainer));
+        GtkWidget *container = moz_container_new();
+        mContainer = MOZ_CONTAINER(container);
+        gtk_container_add(GTK_CONTAINER(mShell), container);
+        gtk_widget_realize(container);
 
         // make sure this is the focus widget in the container
-        gtk_window_set_focus(GTK_WINDOW(mShell), GTK_WIDGET(mContainer));
+        gtk_window_set_focus(GTK_WINDOW(mShell), container);
 
         // and the drawing area
-        mDrawingarea = moz_drawingarea_new(nsnull, mContainer, visual);
+        mGdkWindow = CreateGdkWindow(container->window, container);
 
         if (mWindowType == eWindowType_popup) {
             // gdk does not automatically set the cursor for "temporary"
@@ -4033,14 +4035,15 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
         break;
     case eWindowType_child: {
         if (parentMozContainer) {
-            mDrawingarea = moz_drawingarea_new(parentArea, parentMozContainer, visual);
+            mGdkWindow = CreateGdkWindow(parentGdkWindow, parentMozContainer);
         }
         else if (parentGtkContainer) {
-            mContainer = MOZ_CONTAINER(moz_container_new());
-            gtk_container_add(parentGtkContainer, GTK_WIDGET(mContainer));
-            gtk_widget_realize(GTK_WIDGET(mContainer));
+            GtkWidget *container = moz_container_new();
+            mContainer = MOZ_CONTAINER(container);
+            gtk_container_add(parentGtkContainer, container);
+            gtk_widget_realize(container);
 
-            mDrawingarea = moz_drawingarea_new(nsnull, mContainer, visual);
+            mGdkWindow = CreateGdkWindow(container->window, container);
         }
         else {
             NS_WARNING("Warning: tried to create a new child widget with no parent!");
@@ -4061,17 +4064,8 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
         gtk_widget_set_double_buffered (GTK_WIDGET(mContainer),FALSE);
 #endif
 
-    // label the drawing area with this object so we can find our way
-    // home
-    g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "nsWindow",
-                      this);
-    g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "nsWindow",
-                      this);
-
-    g_object_set_data(G_OBJECT(mDrawingarea->clip_window), "mozdrawingarea",
-                      mDrawingarea);
-    g_object_set_data(G_OBJECT(mDrawingarea->inner_window), "mozdrawingarea",
-                      mDrawingarea);
+    // label the drawing window with this object so we can find our way home
+    g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", this);
 
     if (mContainer)
         g_object_set_data(G_OBJECT(mContainer), "nsWindow", this);
@@ -4162,12 +4156,9 @@ nsWindow::NativeCreate(nsIWidget        *aParent,
              GDK_WINDOW_XWINDOW(GTK_WIDGET(mContainer)->window)));
     }
 
-    if (mDrawingarea) {
-        LOG(("\tmDrawingarea %p %p %p %lx %lx\n", (void *)mDrawingarea,
-             (void *)mDrawingarea->clip_window,
-             (void *)mDrawingarea->inner_window,
-             GDK_WINDOW_XWINDOW(mDrawingarea->clip_window),
-             GDK_WINDOW_XWINDOW(mDrawingarea->inner_window)));
+    if (mGdkWindow) {
+        LOG(("\tmGdkWindow %p %lx\n", (void *)mGdkWindow,
+             GDK_WINDOW_XWINDOW(mGdkWindow)));
     }
 
     // resize so that everything is set to the right dimensions
@@ -4333,8 +4324,8 @@ nsWindow::NativeResize(PRInt32 aWidth, PRInt32 aHeight, PRBool  aRepaint)
         gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
     }
 
-    if (mDrawingarea) {
-        moz_drawingarea_resize (mDrawingarea, aWidth, aHeight);
+    if (mGdkWindow) {
+        gdk_window_resize(mGdkWindow, aWidth, aHeight);
     }
 }
 
@@ -4360,7 +4351,7 @@ nsWindow::NativeResize(PRInt32 aX, PRInt32 aY,
             gtk_window_move(GTK_WINDOW(mShell), aX, aY);
 
         gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
-        moz_drawingarea_resize(mDrawingarea, aWidth, aHeight);
+        gdk_window_resize(mGdkWindow, aWidth, aHeight);
     }
     else if (mContainer) {
         GtkAllocation allocation;
@@ -4369,10 +4360,10 @@ nsWindow::NativeResize(PRInt32 aX, PRInt32 aY,
         allocation.width = aWidth;
         allocation.height = aHeight;
         gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
-        moz_drawingarea_move_resize(mDrawingarea, aX, aY, aWidth, aHeight);
+        gdk_window_move_resize(mGdkWindow, aX, aY, aWidth, aHeight);
     }
-    else if (mDrawingarea) {
-        moz_drawingarea_move_resize(mDrawingarea, aX, aY, aWidth, aHeight);
+    else if (mGdkWindow) {
+        gdk_window_move_resize(mGdkWindow, aX, aY, aWidth, aHeight);
     }
 }
 
@@ -4401,16 +4392,16 @@ nsWindow::NativeShow (PRBool  aAction)
                 SetUserTimeAndStartupIDForActivatedWindow(mShell);
             }
 
-            moz_drawingarea_set_visibility(mDrawingarea, aAction);
+            gdk_window_show_unraised(mGdkWindow);
             gtk_widget_show(GTK_WIDGET(mContainer));
             gtk_widget_show(mShell);
         }
         else if (mContainer) {
-            moz_drawingarea_set_visibility(mDrawingarea, TRUE);
+            gdk_window_show_unraised(mGdkWindow);
             gtk_widget_show(GTK_WIDGET(mContainer));
         }
-        else if (mDrawingarea) {
-            moz_drawingarea_set_visibility(mDrawingarea, TRUE);
+        else if (mGdkWindow) {
+            gdk_window_show_unraised(mGdkWindow);
         }
     }
     else {
@@ -4420,10 +4411,10 @@ nsWindow::NativeShow (PRBool  aAction)
         }
         else if (mContainer) {
             gtk_widget_hide(GTK_WIDGET(mContainer));
-            moz_drawingarea_set_visibility(mDrawingarea, FALSE);
+            gdk_window_hide(mGdkWindow);
         }
-        if (mDrawingarea) {
-            moz_drawingarea_set_visibility(mDrawingarea, FALSE);
+        if (mGdkWindow) {
+            gdk_window_hide(mGdkWindow);
         }
     }
 }
@@ -4684,11 +4675,11 @@ nsWindow::GrabPointer(void)
         return;
     }
 
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return;
 
     gint retval;
-    retval = gdk_pointer_grab(mDrawingarea->inner_window, TRUE,
+    retval = gdk_pointer_grab(mGdkWindow, TRUE,
                               (GdkEventMask)(GDK_BUTTON_PRESS_MASK |
                                              GDK_BUTTON_RELEASE_MASK |
                                              GDK_ENTER_NOTIFY_MASK |
@@ -4730,8 +4721,8 @@ nsWindow::GrabKeyboard(void)
 
     if (mTransientParent)
         grabWindow = GTK_WIDGET(mTransientParent)->window;
-    else if (mDrawingarea)
-        grabWindow = mDrawingarea->inner_window;
+    else if (mGdkWindow)
+        grabWindow = mGdkWindow;
     else
         return;
 
@@ -4777,11 +4768,11 @@ nsWindow::GetToplevelWidget(GtkWidget **aWidget)
 GtkWidget *
 nsWindow::GetMozContainerWidget()
 {
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return NULL;
 
     GtkWidget *owningWidget =
-        get_gtk_widget_for_gdk_window(mDrawingarea->inner_window);
+        get_gtk_widget_for_gdk_window(mGdkWindow);
     return owningWidget;
 }
 
@@ -4821,10 +4812,10 @@ nsWindow::SetUrgencyHint(GtkWidget *top_window, PRBool state)
 void *
 nsWindow::SetupPluginPort(void)
 {
-    if (!mDrawingarea)
+    if (!mGdkWindow)
         return nsnull;
 
-    if (GDK_WINDOW_OBJECT(mDrawingarea->inner_window)->destroyed == TRUE)
+    if (GDK_WINDOW_OBJECT(mGdkWindow)->destroyed == TRUE)
         return nsnull;
 
     // we have to flush the X queue here so that any plugins that
@@ -4832,22 +4823,19 @@ nsWindow::SetupPluginPort(void)
     // this window in case it was just created
 #ifdef MOZ_X11
     XWindowAttributes xattrs;
-    XGetWindowAttributes(GDK_DISPLAY (),
-                         GDK_WINDOW_XWINDOW(mDrawingarea->inner_window),
+    XGetWindowAttributes(GDK_DISPLAY(), GDK_WINDOW_XWINDOW(mGdkWindow),
                          &xattrs);
     XSelectInput (GDK_DISPLAY (),
-                  GDK_WINDOW_XWINDOW(mDrawingarea->inner_window),
+                  GDK_WINDOW_XWINDOW(mGdkWindow),
                   xattrs.your_event_mask |
                   SubstructureNotifyMask);
 
-    gdk_window_add_filter(mDrawingarea->inner_window,
-                          plugin_window_filter_func,
-                          this);
+    gdk_window_add_filter(mGdkWindow, plugin_window_filter_func, this);
 
     XSync(GDK_DISPLAY(), False);
 #endif /* MOZ_X11 */
 
-    return (void *)GDK_WINDOW_XWINDOW(mDrawingarea->inner_window);
+    return (void *)GDK_WINDOW_XWINDOW(mGdkWindow);
 }
 
 nsresult
@@ -4907,14 +4895,13 @@ nsWindow::SetNonXEmbedPluginFocus()
     Window curFocusWindow;
     int focusState;
 
-    XGetInputFocus(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
+    XGetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
                    &curFocusWindow,
                    &focusState);
 
     LOGFOCUS(("\t curFocusWindow=%p\n", curFocusWindow));
 
-    GdkWindow* toplevel = gdk_window_get_toplevel
-                                (mDrawingarea->inner_window);
+    GdkWindow* toplevel = gdk_window_get_toplevel(mGdkWindow);
     GdkWindow *gdkfocuswin = gdk_window_lookup(curFocusWindow);
 
     // lookup with the focus proxy window is supposed to get the
@@ -4926,11 +4913,11 @@ nsWindow::SetNonXEmbedPluginFocus()
 
     // switch the focus from the focus proxy to the plugin window
     mOldFocusWindow = curFocusWindow;
-    XRaiseWindow(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
-                 GDK_WINDOW_XWINDOW(mDrawingarea->inner_window));
+    XRaiseWindow(GDK_WINDOW_XDISPLAY(mGdkWindow),
+                 GDK_WINDOW_XWINDOW(mGdkWindow));
     gdk_error_trap_push();
-    XSetInputFocus(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
-                   GDK_WINDOW_XWINDOW(mDrawingarea->inner_window),
+    XSetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
+                   GDK_WINDOW_XWINDOW(mGdkWindow),
                    RevertToNone,
                    CurrentTime);
     gdk_flush();
@@ -4939,8 +4926,7 @@ nsWindow::SetNonXEmbedPluginFocus()
     gdk_window_add_filter(NULL, plugin_client_message_filter, this);
 
     LOGFOCUS(("nsWindow::SetNonXEmbedPluginFocus oldfocus=%p new=%p\n",
-                mOldFocusWindow,
-                GDK_WINDOW_XWINDOW(mDrawingarea->inner_window)));
+              mOldFocusWindow, GDK_WINDOW_XWINDOW(mGdkWindow)));
 }
 
 void
@@ -4957,7 +4943,7 @@ nsWindow::LoseNonXEmbedPluginFocus()
     Window curFocusWindow;
     int focusState;
 
-    XGetInputFocus(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
+    XGetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
                    &curFocusWindow,
                    &focusState);
 
@@ -4966,12 +4952,12 @@ nsWindow::LoseNonXEmbedPluginFocus()
     // event filter that blocks the WM_TAKE_FOCUS is enough. WM and gtk2
     // will take care of the focus later.
     if (!curFocusWindow ||
-        curFocusWindow == GDK_WINDOW_XWINDOW(mDrawingarea->inner_window)) {
+        curFocusWindow == GDK_WINDOW_XWINDOW(mGdkWindow)) {
 
         gdk_error_trap_push();
-        XRaiseWindow(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
+        XRaiseWindow(GDK_WINDOW_XDISPLAY(mGdkWindow),
                      mOldFocusWindow);
-        XSetInputFocus(GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
+        XSetInputFocus(GDK_WINDOW_XDISPLAY(mGdkWindow),
                        mOldFocusWindow,
                        RevertToParent,
                        CurrentTime);
@@ -6655,13 +6641,11 @@ nsWindow::IMESetCursorPosition(const nsTextEventReply& aReply)
 
     // Get the position of the refWindow in screen.
     gint refX, refY;
-    gdk_window_get_origin(refWindow->mDrawingarea->inner_window,
-                          &refX, &refY);
+    gdk_window_get_origin(refWindow->mGdkWindow, &refX, &refY);
 
     // Get the position of IM context owner window in screen.
     gint ownerX, ownerY;
-    gdk_window_get_origin(ownerWindow->mDrawingarea->inner_window,
-                          &ownerX, &ownerY);
+    gdk_window_get_origin(ownerWindow->mGdkWindow, &ownerX, &ownerY);
 
     // Compute the caret position in the IM owner window.
     GdkRectangle area;
@@ -6807,7 +6791,7 @@ nsWindow::GetToggledKeyState(PRUint32 aKeyCode, PRBool* aLEDState)
     GdkModifierType modifiers = gdk_keyboard_get_modifiers();
     PRUint32 capsLockMask, numLockMask, scrollLockMask;
     PRBool foundMasks = gdk_keyboard_get_modmap_masks(
-                          GDK_WINDOW_XDISPLAY(mDrawingarea->inner_window),
+                          GDK_WINDOW_XDISPLAY(mGdkWindow),
                           &capsLockMask, &numLockMask, &scrollLockMask);
     if (!foundMasks)
         return NS_ERROR_NOT_IMPLEMENTED;
@@ -7140,8 +7124,7 @@ nsWindow::GetThebesSurface()
 {
     GdkDrawable* d;
     gint x_offset, y_offset;
-    gdk_window_get_internal_paint_info(mDrawingarea->inner_window,
-                                       &d, &x_offset, &y_offset);
+    gdk_window_get_internal_paint_info(mGdkWindow, &d, &x_offset, &y_offset);
 
 #ifdef MOZ_X11
     gint width, height;
@@ -7217,7 +7200,7 @@ nsWindow::BeginResizeDrag(nsGUIEvent* aEvent, PRInt32 aHorizontal, PRInt32 aVert
     }
 
     // get the gdk window for this widget
-    GdkWindow* gdk_window = mDrawingarea->inner_window;
+    GdkWindow* gdk_window = mGdkWindow;
     if (!GDK_IS_WINDOW(gdk_window)) {
       return NS_ERROR_FAILURE;
     }
diff --git a/widget/src/gtk2/nsWindow.h b/widget/src/gtk2/nsWindow.h
index 23aa482..66d713b 100644
--- a/widget/src/gtk2/nsWindow.h
+++ b/widget/src/gtk2/nsWindow.h
@@ -43,7 +43,6 @@
 #include "nsAutoPtr.h"
 
 #include "mozcontainer.h"
-#include "mozdrawingarea.h"
 #include "nsWeakReference.h"
 
 #include "nsIDragService.h"
@@ -492,7 +491,7 @@ private:
 
     GtkWidget          *mShell;
     MozContainer       *mContainer;
-    MozDrawingarea     *mDrawingarea;
+    GdkWindow          *mGdkWindow;
 
     GtkWindowGroup     *mWindowGroup;
 
-- 
1.7.0.rc0.69.g2ee80

